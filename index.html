<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>サイコロモンスターズ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700;900&family=Orbitron:wght@500;700&display=swap');

        :root {
            --primary-color: #0d1b2a; /* Dark Navy */
            --secondary-color: #1b263b; /* Darker Blue-Gray */
            --accent-color: #ffc107; /* Gold */
            --accent-hover-color: #ffca2c;
            --text-light: #e0e0e0;
            --text-dark: #1a1a1a;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
            --font-main: 'Noto Sans JP', sans-serif;
            --font-accent: 'Orbitron', sans-serif; 
        }

        body {
            font-family: var(--font-main);
            margin: 0;
            padding: 0;
            background: 
                linear-gradient(rgba(13, 27, 42, 0.85), rgba(13, 27, 42, 0.95)),
                url('images/闘技場.png') center center / cover no-repeat fixed;
            color: var(--text-light);
            display: flex;
            justify-content: center; 
            align-items: center; 
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            height: 100%; /* Fill parent (body which is 100vh) */
            width: 100%;
            max-width: 480px;
            background-color: rgba(27, 38, 59, 0.9); 
            backdrop-filter: blur(8px);
            overflow: hidden; 
            border-radius: 0; 
            box-shadow: 0 15px 35px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
        }
      
        .info-area { 
            flex-shrink: 0;
            height: 11%; 
        }
        .character-display-area { 
            flex-shrink: 0;
            height: 22%; 
            display: flex; /* Added for centering */
            justify-content: center; /* Added for centering */
            align-items: center; /* Added for centering */
        }
        .message-log-area { 
            flex-grow: 1; 
            min-height: 80px; /* Minimum height */
            height: auto; /* Allow it to take remaining space */
            overflow-y: auto;
        }
        .command-area { 
            flex-shrink: 0; 
            height: auto; /* Height based on content */
            padding-top: 10px; 
            padding-bottom: 15px; /* Ensure padding for safe area or visibility */
        }


        /* Area Styling */
        .info-area, .character-display-area, .message-log-area, .command-area {
            padding: 8px 12px; 
            box-sizing: border-box;
            position: relative; 
        }
        
        .info-area {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: rgba(255,255,255,0.02);
            border-bottom: 1px solid rgba(255,193,7, 0.2); 
        }
        .character-stats {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-grow: 1;
            padding-left: 10px;
        }
        .character-stats .name {
            font-family: var(--font-accent);
            font-size: 1.2em; 
            font-weight: 700; 
            color: var(--accent-color); 
            text-shadow: 0 0 8px rgba(255,193,7,0.7);
        }
        .hp-bar-container {
            width: 100%;
            height: 20px; 
            background-color: rgba(0,0,0,0.3); 
            border-radius: 10px;
            overflow: hidden;
            margin-top: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
        }
        .hp-bar {
            height: 100%;
            background: linear-gradient(to right, #5cb85c, #81c784); 
            width: 100%;
            transition: width 0.6s cubic-bezier(0.23, 1, 0.32, 1); 
            border-radius: 10px 0 0 10px;
            box-shadow: inset 0 0 5px rgba(255,255,255,0.2);
        }
        .hp-bar.low { background: linear-gradient(to right, #d9534f, #e57373); } 
        .hp-bar.medium { background: linear-gradient(to right, #f0ad4e, #ffb74d); } 
        #opponentHpText, #playerHpText {
            font-size: 0.8em;
            color: #d0d0d0;
            margin-top: 3px;
            font-weight: 700;
        }

        .status-icons { 
            display: flex;
            flex-wrap: wrap; 
            gap: 4px;
            margin-top: 3px;
            max-height: 20px; 
            overflow: hidden;
        }
        .status-icons span { 
            background-color: rgba(0,0,0,0.6);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            border: 1px solid rgba(255,255,255,0.25);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            transition: transform 0.2s ease;
            white-space: nowrap;
        }
        .status-icons span:hover {
            transform: scale(1.1);
        }


        .thumbnail img {
             width: 55px; height: 41px; 
             border-radius: 6px;
             border: 2px solid var(--accent-color); 
             box-shadow: 0 3px 7px rgba(0,0,0,0.4);
        }

        .character-display-area img {
            max-width: 85%;
            max-height: 85%;
            object-fit: contain;
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.6)); 
            transition: transform 0.4s ease-in-out, filter 0.4s ease-in-out;
        }
        .character-display-area img.active-char { 
            transform: scale(1.05);
            filter: drop-shadow(0 10px 25px var(--accent-color));
        }


        .message-log-area {
            background-color: rgba(0, 0, 0, 0.5); 
            border-radius: 10px;
            padding: 12px;
            font-size: 0.85em; 
            border: 1px solid rgba(255,193,7, 0.2); 
            box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
        }
        .message-log-area p {
            margin: 5px 0;
            line-height: 1.5;
            color: var(--text-light);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            opacity: 0; 
            animation: fadeInMessage 0.5s forwards;
        }
        @keyframes fadeInMessage {
            to { opacity: 1; transform: translateY(0); }
        }
        .message-log-area p:nth-last-child(-n+1) { 
             animation-delay: 0.1s;
        }


         .message-log-area::-webkit-scrollbar {
            width: 8px;
        }
        .message-log-area::-webkit-scrollbar-thumb {
            background-color: rgba(255,193,7,0.5); 
            border-radius: 4px;
        }

        .command-area {
            display: flex;
            flex-direction: column;
            justify-content: space-around; /* This helps distribute space */
            background: transparent; 
            border-top: 1px solid rgba(255,193,7, 0.2); 
        }
        .skills-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px; /* Slightly reduced gap */
            margin-bottom: 8px; /* Slightly reduced margin */
        }
        .skill-slot {
            background: linear-gradient(145deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: var(--text-light);
            padding: 8px 5px; /* Adjusted padding */
            text-align: center;
            border-radius: 8px; 
            font-size: 0.75em; /* Adjusted font size */
            font-weight: 700;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            transition: all 0.25s ease;
            box-shadow: 0 3px 5px rgba(0,0,0,0.25), inset 0 1px 1px rgba(255,255,255,0.08);
            cursor: default; 
        }
        .skill-slot.highlighted {
            background: linear-gradient(145deg, var(--accent-color), #e6a700); 
            color: var(--primary-color); 
            border-color: #c89200;
            transform: scale(1.08) translateY(-2px); 
            box-shadow: 0 5px 15px rgba(255,193,7,0.5);
        }

        .dice-and-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 5px; /* Add some top margin */
        }
        .dice-display {
            font-family: var(--font-accent);
            font-size: 3em; /* Slightly reduced */
            font-weight: 700;
            width: 65px; 
            height: 65px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, #f8f9fa, #e9ecef); 
            color: var(--primary-color); 
            border-radius: 10px; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 -2px 4px rgba(0,0,0,0.1);
            text-shadow: 1px 1px 0px rgba(255,255,255,0.8);
        }
        .dice-display.rolling {
            animation: diceRollAdvanced 0.08s infinite; 
        }
        @keyframes diceRollAdvanced {
            0% { transform: rotateY(0deg) rotateX(0deg) scale(1); box-shadow: 0 5px 10px rgba(0,0,0,0.35); }
            50% { transform: rotateY(180deg) rotateX(180deg) scale(1.2); box-shadow: 0 8px 20px rgba(0,0,0,0.5); }
            100% { transform: rotateY(360deg) rotateX(360deg) scale(1); box-shadow: 0 5px 10px rgba(0,0,0,0.35); }
        }


        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px; /* Reduced gap */
            flex-grow: 1;
            margin-left: 10px;
        }
        .action-buttons button {
            color: white;
            border: none;
            padding: 8px 10px; /* Reduced padding */
            border-radius: 6px; /* Slightly less radius */
            font-size: 0.85em; /* Reduced font size */
            font-family: var(--font-accent);
            font-weight: 700; 
            cursor: pointer;
            transition: all 0.2s ease-out;
            text-transform: uppercase; 
            letter-spacing: 1px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.25);
            border-bottom: 2px solid transparent; /* Reduced border */
        }
        .action-buttons button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.35);
            filter: brightness(1.1);
        }
        .action-buttons button:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border-bottom-width: 0px;
            margin-top: 2px; 
        }
        .action-buttons button:disabled {
            background-color: #4a5568 !important; 
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        #rollDiceButton { background: linear-gradient(145deg, var(--success-color), #1e7e34); border-bottom-color: #19692c;}
        #confirmSkillButton { background: linear-gradient(145deg, var(--accent-color), #d4a006); color: var(--primary-color); border-bottom-color: #b08800;}
        #useLuckButton { background: linear-gradient(145deg, var(--info-color), #117a8b); border-bottom-color: #0e6676;}


        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; 
            background-color: rgba(10, 20, 40, 0.85); 
            backdrop-filter: blur(10px); 
            padding-top: 20px; 
            padding-bottom: 20px; 
        }
        .modal-content {
            background: linear-gradient(145deg, var(--secondary-color), var(--primary-color)); 
            margin: auto;
            padding: 25px;
            border: 1px solid rgba(255,193,7,0.3); 
            width: 90%;
            max-width: 480px; 
            border-radius: 15px; 
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
            color: var(--text-light);
        }
        .modal-content h1 {
            font-family: var(--font-accent);
            font-size: 2.5em; 
            margin-bottom: 15px;
            color: var(--accent-color); 
            text-shadow: 0 0 10px rgba(255,193,7,0.8);
        }
        .modal-content h2 {
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 1.4em;
            color: #e0e0e0;
        }
        .modal-content button { 
            background: linear-gradient(145deg, var(--accent-color), #e6a700);
            color: var(--primary-color);
            border: none;
            padding: 14px 30px; 
            border-radius: 10px;
            font-size: 1.1em;
            font-family: var(--font-accent);
            font-weight: 700;
            cursor: pointer;
            margin-top: 25px;
            transition: all 0.2s ease-out;
            box-shadow: 0 4px 8px rgba(0,0,0,0.25);
        }
         .modal-content button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 6px 15px rgba(255,193,7,0.4); 
            filter: brightness(1.15);
        }
        
        #characterChoices {
            display: flex;
            flex-direction: column; 
            gap: 25px; 
            align-items: center; 
            max-height: 60vh; 
            overflow-y: auto; 
            padding: 10px; 
        }

        .character-card {
            background: linear-gradient(145deg, rgba(40, 58, 88, 0.9), rgba(27, 38, 59, 0.95)); 
            border: 1px solid rgba(255,193,7,0.25); 
            border-radius: 15px; 
            padding: 20px; 
            width: 100%; 
            max-width: 400px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            text-align: left;
            color: var(--text-light); 
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.3s ease-out, border-color 0.3s ease-out;
        }
        .character-card:hover {
            transform: translateY(-6px) scale(1.03); 
            box-shadow: 0 8px 25px rgba(255,193,7,0.3); 
            border-color: rgba(255,193,7,0.6); 
        }
        .character-card img.card-char-image {
            width: 100%;
            height: 220px; 
            object-fit: contain; 
            border-radius: 10px;
            margin-bottom: 15px;
            background-color: rgba(0,0,0,0.3); 
            border: 1px solid rgba(255,255,255,0.15);
            padding: 5px; 
        }
        .character-card h3.card-char-name {
            font-family: var(--font-accent);
            font-size: 1.8em;
            font-weight: 700;
            color: var(--accent-color); 
            margin-bottom: 12px;
            text-align: center;
            text-shadow: 0 0 8px rgba(255,193,7,0.7);
        }
        .card-section-title {
            font-size: 1.1em; 
            font-weight: 700;
            color: #c0c8d0; 
            margin-top: 15px;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(255,193,7,0.2); 
            padding-bottom: 5px;
        }
        .card-stats p, .card-trait p, .card-skills li {
            font-size: 0.95em; 
            margin-bottom: 6px;
            line-height: 1.6;
        }
        .card-trait .trait-name {
            font-weight: 700;
            color: #e0e0e0; 
        }
        .card-skills ul {
            list-style: none;
            padding-left: 0;
        }
        .card-skills li {
            background-color: rgba(0,0,0,0.25);
            padding: 5px 10px; 
            border-radius: 6px;
            margin-bottom: 5px;
            border-left: 4px solid var(--accent-color); 
            transition: background-color 0.2s ease;
        }
        .card-skills li:hover {
            background-color: rgba(255,193,7, 0.15); 
        }

        .hidden { display: none !important; }

        img[alt]:after {
            content: attr(alt);
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #333;
            color: #fff;
            font-size: 0.8em;
            text-align: center;
            padding-top: 20%; 
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="opponentInfoArea" class="info-area">
            <div class="thumbnail">
                <img id="opponentThumbnail" src="" alt="相手サムネ">
            </div>
            <div class="character-stats">
                <span id="opponentName" class="name">相手キャラ</span>
                <div class="hp-bar-container">
                    <div id="opponentHpBar" class="hp-bar"></div>
                </div>
                <span id="opponentHpText">HP: ---/---</span>
                <div id="opponentStatusIcons" class="status-icons"></div>
            </div>
        </div>

        <div id="opponentCharacterArea" class="character-display-area">
            <img id="opponentImage" src="" alt="相手キャラ画像">
        </div>

        <div id="playerCharacterArea" class="character-display-area">
            <img id="playerImage" src="" alt="自分キャラ画像">
        </div>

        <div id="playerInfoArea" class="info-area">
             <div class="thumbnail">
                <img id="playerThumbnail" src="" alt="自分サムネ">
            </div>
            <div class="character-stats">
                <span id="playerName" class="name">自分キャラ</span>
                <div class="hp-bar-container">
                    <div id="playerHpBar" class="hp-bar"></div>
                </div>
                <span id="playerHpText">HP: ---/---</span>
                <div id="playerStatusIcons" class="status-icons"></div>
            </div>
        </div>

        <div id="messageLogArea" class="message-log-area">
            <p>ゲームへようこそ！</p>
        </div>

        <div id="commandArea" class="command-area">
            <div class="skills-display">
                <div id="skill1" class="skill-slot">技1</div>
                <div id="skill2" class="skill-slot">技2</div>
                <div id="skill3" class="skill-slot">技3</div>
                <div id="skill4" class="skill-slot">技4</div>
                <div id="skill5" class="skill-slot">技5</div>
                <div id="skill6" class="skill-slot">技6</div>
            </div>
            <div class="dice-and-buttons">
                <div id="diceDisplay" class="dice-display">?</div>
                <div class="action-buttons">
                    <button id="rollDiceButton">サイコロを振る</button>
                    <button id="confirmSkillButton" class="hidden">この目で技を発動</button>
                    <button id="useLuckButton" class="hidden">ラック使用 (残: <span id="luckPointsCount">0</span>)</button>
                </div>
            </div>
        </div>
    </div>

    <div id="characterSelectionModal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h1>サイコロモンスターズ</h1>
            <h2>キャラクターを選択してください</h2>
            <div id="characterChoices">
                </div>
        </div>
    </div>

    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2 id="gameOverMessage"></h2>
            <button id="playAgainButton">もう一度遊ぶ</button>
        </div>
    </div>

    <script>
        (function() {
            // --- DOM Elements ---
            const opponentNameEl = document.getElementById('opponentName');
            const opponentHpBarEl = document.getElementById('opponentHpBar');
            const opponentHpTextEl = document.getElementById('opponentHpText');
            const opponentImageEl = document.getElementById('opponentImage');
            const opponentThumbnailEl = document.getElementById('opponentThumbnail');
            const opponentStatusIconsEl = document.getElementById('opponentStatusIcons');

            const playerNameEl = document.getElementById('playerName');
            const playerHpBarEl = document.getElementById('playerHpBar');
            const playerHpTextEl = document.getElementById('playerHpText');
            const playerImageEl = document.getElementById('playerImage');
            const playerThumbnailEl = document.getElementById('playerThumbnail');
            const playerStatusIconsEl = document.getElementById('playerStatusIcons');

            const messageLogAreaEl = document.getElementById('messageLogArea');
            const skillSlots = [
                document.getElementById('skill1'), document.getElementById('skill2'), document.getElementById('skill3'),
                document.getElementById('skill4'), document.getElementById('skill5'), document.getElementById('skill6')
            ];
            const diceDisplayEl = document.getElementById('diceDisplay');
            const rollDiceButtonEl = document.getElementById('rollDiceButton');
            const useLuckButtonEl = document.getElementById('useLuckButton');
            const confirmSkillButtonEl = document.getElementById('confirmSkillButton');
            const luckPointsCountEl = document.getElementById('luckPointsCount');

            const characterSelectionModalEl = document.getElementById('characterSelectionModal');
            const characterChoicesEl = document.getElementById('characterChoices');
            const gameOverModalEl = document.getElementById('gameOverModal');
            const gameOverMessageEl = document.getElementById('gameOverMessage');
            const playAgainButtonEl = document.getElementById('playAgainButton');


            // --- Sound Files ---
            const sounds = {
                titleBGM: 'sounds/title_bgm.mp3', 
                battleBGM: 'sounds/battle_bgm.mp3',
                diceRoll: 'sounds/dice_roll.mp3',
                skillAttack: 'sounds/skill_attack.mp3',
                skillHeal: 'sounds/skill_heal.mp3',
                damage: 'sounds/damage.mp3',
                win: 'sounds/win.mp3',
                lose: 'sounds/lose.mp3'
            };
            let currentBGM = null;
            let audioContextAllowed = false; 

            function resumeAudioContext() {
                if (!audioContextAllowed && currentBGM && currentBGM.paused) {
                    currentBGM.play().then(() => {
                        audioContextAllowed = true;
                        console.log("AudioContext resumed and BGM started.");
                    }).catch(e => console.warn("AudioContext resume failed or BGM play failed:", e));
                }
            }


            function playSoundEffect(soundFile) {
                if (!audioContextAllowed && !currentBGM) { 
                    const tempAudio = new Audio(); 
                    tempAudio.play().then(() => { audioContextAllowed = true; }).catch(()=>{});
                }
                if (!audioContextAllowed && soundFile === sounds.diceRoll) {
                } else {
                    try {
                        const audio = new Audio(soundFile);
                        audio.play().catch(e => console.warn(`効果音の再生に失敗: ${soundFile}`, e));
                    } catch (e) {
                        console.warn(`効果音の読み込み/再生エラー: ${soundFile}`, e);
                    }
                }
            }

            function playBGM(soundFile, loop = true) {
                stopBGM(); 
                try {
                    currentBGM = new Audio(soundFile);
                    currentBGM.loop = loop;
                    currentBGM.play().then(() => {
                        audioContextAllowed = true; 
                    }).catch(e => {
                        console.warn(`BGMの再生に失敗: ${soundFile}. User interaction might be required.`, e);
                        document.body.addEventListener('click', resumeAudioContext, { once: true });
                        document.body.addEventListener('touchstart', resumeAudioContext, { once: true });

                    });
                } catch (e) {
                    console.warn(`BGMの読み込み/再生エラー: ${soundFile}`, e);
                }
            }

            function stopBGM() {
                if (currentBGM) {
                    currentBGM.pause();
                    currentBGM.currentTime = 0;
                    currentBGM = null;
                }
                 document.body.removeEventListener('click', resumeAudioContext);
                 document.body.removeEventListener('touchstart', resumeAudioContext);
            }

            const onImageError = (e) => {
                e.target.alt = `${e.target.alt.replace('画像', '')}読込失敗`;
                e.target.style.backgroundColor = '#444';
                e.target.style.border = '1px dashed #888';
                e.target.src = 'https://placehold.co/300x225/333333/FFFFFF?text=' + encodeURIComponent(e.target.alt.replace('画像',''));
            };
            
            const characters = {
                volfang: {
                    id: "volfang", name: "ヴォルファング", imageFile: "images/ヴォルフォング.png", hp: 320, maxHp: 320, speed: 140,
                    trait: { name: "闘争本能", description: "HPが半分以下で攻撃技の威力微増。", apply: function(self, opponent, game) { if (self.hp <= self.maxHp / 2) game.logMessage(`${self.name}の特性「闘争本能」発動！攻撃力が上がった！`); } },
                    skills: [
                        null,
                        { name: "ひっかく", type: "攻撃", power: 30, description: "鋭い爪で相手をひっかく通常攻撃。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); } },
                        { name: "遠吠え", type: "補助", description: "戦意を高める遠吠えで、自身の攻撃力を2ターン上げる。", effect: function(self, opponent, game) { game.addStatus(self, {name: "攻撃アップ", turns: 2, type: "buff", stat: "attack", value: 1.2}); } },
                        { name: "かみくだく", type: "攻撃", power: 50, description: "強靭な顎で相手に噛みつき、ダメージを与える。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); } },
                        { name: "たいあたり", type: "攻撃", power: 70, recoil: 15, description: "全身で相手に突撃する。自身も少しダメージを受ける。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); game.dealDamage(self, this.recoil, self, true);} },
                        { name: "ワイルドクロー", type: "攻撃", power: 25, hits: 2, description: "素早い爪攻撃を2回繰り出す。", effect: function(self, opponent, game) { for(let i=0; i<this.hits; i++) { if(opponent.hp > 0) game.dealDamage(opponent, this.power, self);} } },
                        { name: "ハウリングレイジ", type: "攻撃", power: 100, description: "怒りの咆哮と共に強力な一撃。30%の確率で次のターン動けない。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); if (Math.random() < 0.3) { game.addStatus(self, {name: "行動不能", turns: 1, type: "debuff"}); game.logMessage(`${self.name}は反動で動けない！`); } } },
                    ]
                },
                basaltus: {
                    id: "basaltus", name: "バサルタス", imageFile: "images/バサルタス.png", hp: 400, maxHp: 400, speed: 80,
                    trait: { name: "頑強な甲殻", description: "硬い甲殻で物理技のダメージを少し軽減する。", apply: function(self, opponent, game) { /* Effect applied in dealDamage */ } },
                    skills: [
                        null,
                        { name: "ぶつかる", type: "攻撃", power: 25, description: "岩の体で相手にぶつかる通常攻撃。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); } },
                        { name: "硬くなる", type: "補助", description: "自身の体をさらに硬化させ、防御力を2ターン上げる。", effect: function(self, opponent, game) { game.addStatus(self, {name: "防御アップ", turns: 2, type: "buff", stat: "defense", value: 0.8}); } }, 
                        { name: "ロックブラスト", type: "攻撃", power: 45, description: "硬い岩の塊を相手に複数回飛ばす。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); } },
                        { name: "アイアンヘッド", type: "攻撃", power: 60, description: "鋼鉄のような頭で強力な頭突き。20%の確率で相手を怯ませる。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); if (Math.random() < 0.2) { game.addStatus(opponent, {name: "怯み", turns: 1, type: "debuff"}); game.logMessage(`${opponent.name}は怯んで動けない！`); } } },
                        { name: "ステルスロック改", type: "補助", dotDamage: 15, dotTurns: 3, description: "鋭い岩の破片を相手の場に設置し、3ターンダメージを与える。", effect: function(self, opponent, game) { game.addStatus(opponent, {name: "設置ダメージ", turns: this.dotTurns, type: "dot", damage: this.dotDamage}); } },
                        { name: "メガトンプレス", type: "攻撃", power: 120, accuracyRoll: 3, description: "超重量のプレス攻撃。命中すれば絶大だが、当たりにくい(サイコロ3以上で命中)。", effect: function(self, opponent, game) {
                            game.logMessage(`${self.name}のメガトンプレス！ 命中判定中...`);
                            game._animateDiceRoll(self === opponent, () => { 
                                const hitRoll = game.rollDiceInternal();
                                diceDisplayEl.textContent = hitRoll; 
                                game.logMessage(`命中判定サイコロ: ${hitRoll}`);
                                if (hitRoll >= this.accuracyRoll) {
                                    game.logMessage(`命中！`);
                                    game.dealDamage(opponent, this.power, self);
                                } else {
                                    game.logMessage(`しかし、技は外れた！`);
                                }
                                game.updateCharacterUI(); 
                                if (self === opponent && gameActive) { setTimeout(() => game.endTurn(), TURN_TRANSITION_DELAY); }
                                else if (self === player && gameActive) { setTimeout(() => game.endTurn(), TURN_TRANSITION_DELAY); } 
                            }, 500); 
                        }},
                    ]
                },
                lunafox: {
                    id: "lunafox", name: "ルナフォクス", imageFile: "images/ルナフォクス.png", hp: 280, maxHp: 280, speed: 150,
                    trait: { name: "月光の加護", description: "月の光の加護を受け、3ターン毎にHPが少し回復する。", apply: function(self, opponent, game) { if (game.turnCount > 0 && game.turnCount % 3 === 0 && game.currentPlayer === self) { game.healDamage(self, 20); game.logMessage(`${self.name}の特性「月光の加護」！HPが少し回復した！`); } } },
                    skills: [
                        null,
                        { name: "サイコウェーブ", type: "攻撃", power: 35, description: "不思議な精神の波で相手を攻撃する。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); } },
                        { name: "めいそう", type: "回復", heal: 50, description: "精神を集中し、自身のHPを少し回復する。", effect: function(self, opponent, game) { game.healDamage(self, this.heal); } },
                        { name: "シャドーボール", type: "攻撃", power: 55, description: "影の塊を相手に放つ。20%の確率で相手の攻撃力を下げる。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); if (Math.random() < 0.2) { game.addStatus(opponent, {name: "攻撃ダウン", turns: 2, type: "debuff", stat: "attack", value: 0.8}); game.logMessage(`${opponent.name}の攻撃力が下がった！`); } } },
                        { name: "つきのひかり", type: "回復", heal: 80, description: "月の光を浴びて、自身のHPを中程度回復する。", effect: function(self, opponent, game) { game.healDamage(self, this.heal); } },
                        { name: "あやしいひかり", type: "状態異常", description: "幻惑の光で相手を混乱状態にする(2ターン)。", effect: function(self, opponent, game) { game.addStatus(opponent, {name: "混乱", turns: 2, type: "debuff"}); game.logMessage(`${opponent.name}は混乱した！`); } },
                        { name: "ムーンフォース", type: "攻撃", power: 90, description: "月の神秘的な力で大ダメージ。20%の確率で自身の攻撃力UP。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); if (Math.random() < 0.2) { game.addStatus(self, {name: "攻撃アップ", turns: 2, type: "buff", stat: "attack", value: 1.2}); game.logMessage(`${self.name}の攻撃力が上がった！`); } } },
                    ]
                },
                flaregriffon: {
                    id: "flaregriffon", name: "フレアグリフォン", imageFile: "images/フレアグリフォン.png", hp: 300, maxHp: 300, speed: 160,
                    trait: { name: "はやてのつばさ", description: "疾風の翼で、ターン開始時に20%の確率で自身の速さが上がる。", apply: function(self, opponent, game) { if (Math.random() < 0.2 && game.currentPlayer === self) { game.logMessage(`${self.name}の特性「はやてのつばさ」！速さが上がった！`); } } },
                    skills: [
                        null,
                        { name: "つつく", type: "攻撃", power: 30, description: "鋭いくちばしで相手をつつく通常攻撃。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); } },
                        { name: "ニトロチャージ", type: "攻撃", power: 40, description: "炎を纏って突撃しダメージ。自身の速さが上がる。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); game.logMessage(`${self.name}の「ニトロチャージ」！速さが上がった！`);} },
                        { name: "エアカッター", type: "攻撃", power: 20, hits: 2, description: "真空の刃を2回放ち、相手を切り裂く。", effect: function(self, opponent, game) { for(let i=0; i<this.hits; i++) { if(opponent.hp > 0) game.dealDamage(opponent, this.power, self);}} },
                        { name: "かえんほうしゃ", type: "攻撃", power: 65, burnChance: 0.3, burnDamage: 15, burnTurns: 3, description: "灼熱の炎を放射して攻撃。30%の確率で相手をやけど状態にする(3ターン)。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); if (Math.random() < this.burnChance) { game.addStatus(opponent, {name: "やけど", turns: this.burnTurns, type: "dot", damage: this.burnDamage}); game.logMessage(`${opponent.name}はやけどを負った！`); } } },
                        { name: "おいかぜ", type: "補助", description: "追い風を起こし、3ターンの間、自身の速さを2倍にする。", effect: function(self, opponent, game) { game.logMessage(`${self.name}の「おいかぜ」！速さが大幅に上がった！`); } },
                        { name: "ブレイブバード", type: "攻撃", power: 110, recoil: 30, description: "命知らずの突撃で超大ダメージ。自身も大きな反動ダメージを受ける。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); game.dealDamage(self, this.recoil, self, true); } },
                    ]
                },
                aquaserpent: {
                    id: "aquaserpent", name: "アクアサーペント", imageFile: "images/アクアサーペント.png", hp: 350, maxHp: 350, speed: 120,
                    trait: { name: "うるおいボディ改", description: "潤いに満ちた体で、ターン終了時にHPが少し回復する。", apply: function(self, opponent, game) { if (game.currentPlayer !== self && self.hp > 0) { game.healDamage(self, 15); game.logMessage(`${self.name}の特性「うるおいボディ改」！HPが少し回復した！`); } } },
                    skills: [
                        null,
                        { name: "みずでっぽう", type: "攻撃", power: 30, description: "水の弾を発射する通常攻撃。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); } },
                        { name: "アクアリング", type: "回復", hotHeal: 20, hotTurns: 3, description: "水のリングを身にまとい、3ターンの間HPが徐々に回復する。", effect: function(self, opponent, game) { game.addStatus(self, {name: "HP継続回復", turns: this.hotTurns, type: "hot", heal: this.hotHeal}); } },
                        { name: "バブルこうせん", type: "攻撃", power: 45, description: "無数の泡を発射して攻撃。20%の確率で相手の速さを下げる。", effect: function(self, opponent, game) { game.dealDamage(opponent, this.power, self); if (Math.random() < 0.2) { game.logMessage(`${opponent.name}の速さが下がった！`); } } },
                        { name: "りゅうのまい", type: "補助", description: "神秘的な舞で闘争心を高め、自身の攻撃力と速さを上げる。", effect: function(self, opponent, game) { game.addStatus(self, {name: "攻撃アップ", turns: 3, type: "buff", stat: "attack", value: 1.2}); game.logMessage(`${self.name}の攻撃と速さが上がった！`); } },
                        { name: "だくりゅう", type: "攻撃", power: 60, accuracyRoll: 0.8, description: "濁流を発生させて攻撃。命中しにくいが、30%の確率で相手の命中率を下げる。", effect: function(self, opponent, game) { if (Math.random() < this.accuracyRoll) { game.dealDamage(opponent, this.power, self); if (Math.random() < 0.3) game.logMessage(`${opponent.name}の命中率が下がった！`); } else { game.logMessage(`しかし、技は外れた！`); } } },
                        { name: "ハイドロポンプ", type: "攻撃", power: 100, accuracyRoll: 2, description: "高圧の水を噴射して大ダメージ。やや命中しにくい(サイコロ2以上で命中)。", effect: function(self, opponent, game) {
                            game.logMessage(`${self.name}のハイドロポンプ！ 命中判定中...`);
                            game._animateDiceRoll(self === opponent, () => {
                                const hitRoll = game.rollDiceInternal();
                                diceDisplayEl.textContent = hitRoll; 
                                game.logMessage(`命中判定サイコロ: ${hitRoll}`);
                                if (hitRoll >= this.accuracyRoll) {
                                    game.logMessage(`命中！`);
                                    game.dealDamage(opponent, this.power, self);
                                } else {
                                    game.logMessage(`しかし、技は外れた！`);
                                }
                                game.updateCharacterUI(); 
                                if (self === opponent && gameActive) { setTimeout(() => game.endTurn(), TURN_TRANSITION_DELAY); }
                                else if (self === player && gameActive) { setTimeout(() => game.endTurn(), TURN_TRANSITION_DELAY); }
                            }, 500); 
                        }},
                    ]
                }
            };

            // --- Game State ---
            let player, opponent, currentPlayer, turnCount, gameActive, currentDiceRoll;
            let diceRollInterval = null; 
            const TURN_TRANSITION_DELAY = 1500; 

            // --- Helper function to clone character data correctly ---
            function cloneCharacter(charId) {
                const original = characters[charId];
                if (!original) {
                    console.error("Character template not found for ID:", charId);
                    return null;
                }
                const cloned = {
                    id: original.id,
                    name: original.name,
                    imageFile: original.imageFile, 
                    hp: original.maxHp,
                    maxHp: original.maxHp,
                    speed: original.speed,
                    luckPoints: 1, 
                    statusConditions: [], 
                    trait: {
                        name: original.trait.name,
                        description: original.trait.description,
                        apply: original.trait.apply 
                    },
                    skills: original.skills.map(skill => {
                        if (skill) { 
                            return { ...skill }; 
                        }
                        return null; 
                    })
                };
                return cloned;
            }


            const game = {
                logMessage: function(message) {
                    const p = document.createElement('p');
                    p.textContent = message;
                    // Add animation class for new messages
                    p.style.opacity = 0;
                    p.style.transform = 'translateY(10px)';
                    messageLogAreaEl.appendChild(p);
                    // Trigger reflow to ensure animation plays
                    void p.offsetWidth; 
                    p.style.opacity = 1;
                    p.style.transform = 'translateY(0)';
                    p.style.transition = 'opacity 0.3s ease, transform 0.3s ease';

                    messageLogAreaEl.scrollTop = messageLogAreaEl.scrollHeight;
                },
                updateHpUI: function(character, hpBarEl, hpTextEl) {
                    if (!character) return; 
                    const percentage = (character.hp / character.maxHp) * 100;
                    hpBarEl.style.width = percentage + '%';
                    hpTextEl.textContent = `HP: ${character.hp} / ${character.maxHp}`;
                    if (percentage < 25) hpBarEl.className = 'hp-bar low';
                    else if (percentage < 60) hpBarEl.className = 'hp-bar medium';
                    else hpBarEl.className = 'hp-bar';
                },
                updateCharacterUI: function() {
                    if (!player || !opponent) return; 

                    playerNameEl.textContent = player.name;
                    playerImageEl.src = player.imageFile; 
                    playerImageEl.onerror = onImageError;
                    playerThumbnailEl.src = player.imageFile; 
                    playerThumbnailEl.onerror = onImageError;
                    this.updateHpUI(player, playerHpBarEl, playerHpTextEl);
                    if (useLuckButtonEl.querySelector('span')) { 
                        useLuckButtonEl.querySelector('span').textContent = player.luckPoints;
                    }
                    this.updateStatusIcons(player, playerStatusIconsEl);

                    opponentNameEl.textContent = opponent.name;
                    opponentImageEl.src = opponent.imageFile; 
                    opponentImageEl.onerror = onImageError;
                    opponentThumbnailEl.src = opponent.imageFile; 
                    opponentThumbnailEl.onerror = onImageError;
                    this.updateHpUI(opponent, opponentHpBarEl, opponentHpTextEl);
                    this.updateStatusIcons(opponent, opponentStatusIconsEl);

                    // Highlight current player's image
                    if (currentPlayer === player) {
                        playerImageEl.classList.add('active-char');
                        opponentImageEl.classList.remove('active-char');
                    } else {
                        opponentImageEl.classList.add('active-char');
                        playerImageEl.classList.remove('active-char');
                    }


                    for (let i = 0; i < 6; i++) {
                        if (player.skills[i+1]) { 
                            skillSlots[i].textContent = `${i+1}: ${player.skills[i+1].name}`;
                            skillSlots[i].title = player.skills[i+1].description;
                        } else {
                            skillSlots[i].textContent = `-`;
                            skillSlots[i].title = "";
                        }
                    }
                },
                updateStatusIcons: function(character, iconsEl) {
                     if (!character) return;
                    iconsEl.innerHTML = ''; 
                    character.statusConditions.forEach(status => {
                        const iconSpan = document.createElement('span');
                        iconSpan.textContent = `${status.name}(${status.turns})`;
                        iconSpan.title = status.name; 
                        iconSpan.style.backgroundColor = status.type === 'buff' ? 'rgba(76, 175, 80, 0.7)' : 'rgba(244, 67, 54, 0.7)';
                        iconSpan.style.padding = '3px 8px';
                        iconSpan.style.borderRadius = '5px';
                        iconSpan.style.marginRight = '5px';
                        iconSpan.style.fontSize = '0.75em';
                        iconSpan.style.fontWeight = '700';
                        iconSpan.style.border = `1px solid ${status.type === 'buff' ? 'rgba(129, 199, 132, 0.9)' : 'rgba(239, 83, 80, 0.9)'}`;
                        iconsEl.appendChild(iconSpan);
                    });
                },
                rollDiceInternal: function() { 
                    return Math.floor(Math.random() * 6) + 1;
                },
                _animateDiceRoll: function(isCPU, callback, animationTime = 1000) { 
                    if (!gameActive) return;
                    playSoundEffect(sounds.diceRoll); 
                    let animationDuration = animationTime; 
                    let animationInterval = 50; 
                    let elapsed = 0;

                    diceDisplayEl.classList.add('rolling'); 
                    if (!isCPU) { 
                        rollDiceButtonEl.disabled = true;
                        confirmSkillButtonEl.disabled = true;
                        useLuckButtonEl.disabled = true;
                    }

                    diceRollInterval = setInterval(() => {
                        diceDisplayEl.textContent = Math.floor(Math.random() * 6) + 1;
                        elapsed += animationInterval;
                        if (elapsed >= animationDuration) {
                            clearInterval(diceRollInterval);
                            diceRollInterval = null;
                            diceDisplayEl.classList.remove('rolling');
                            callback(); 
                        }
                    }, animationInterval);
                },
                logSkillDetails: function(skill, diceRoll) {
                    if (skill) {
                        let skillInfo = `注目：[${diceRoll}] ${skill.name} (${skill.type})`;
                        if (skill.power !== undefined) { 
                            skillInfo += ` - 威力: ${skill.power}`;
                            if (skill.hits) skillInfo += `x${skill.hits}`;
                        } else if (skill.heal !== undefined) { 
                            skillInfo += ` - 回復量: ${skill.heal}`;
                        } else if (skill.dotDamage !== undefined && skill.dotTurns !== undefined) {
                            skillInfo += ` - ${skill.dotDamage}ダメージ/${skill.dotTurns}ターン`;
                        } else if (skill.hotHeal !== undefined && skill.hotTurns !== undefined) {
                            skillInfo += ` - ${skill.hotHeal}回復/${skill.hotTurns}ターン`;
                        }
                        this.logMessage(skillInfo);
                        this.logMessage(` > ${skill.description}`);
                    }
                },

                rollDice: function() { 
                    if (!gameActive || currentPlayer !== player || diceRollInterval) return; 

                    this.logMessage(`${player.name}がサイコロを振ります...`);
                    diceDisplayEl.textContent = "?"; 

                    this._animateDiceRoll(false, () => { 
                        currentDiceRoll = Math.floor(Math.random() * 6) + 1;
                        diceDisplayEl.textContent = currentDiceRoll;
                        this.logMessage(`${player.name}はサイコロを振って「${currentDiceRoll}」が出た！`);
                        
                        this.logSkillDetails(player.skills[currentDiceRoll], currentDiceRoll);
                        this.logMessage(`技を発動するか、ラックポイントを使用してください。`);

                        skillSlots.forEach(slot => slot.classList.remove('highlighted'));
                        if (skillSlots[currentDiceRoll - 1]) {
                            skillSlots[currentDiceRoll - 1].classList.add('highlighted');
                        }

                        rollDiceButtonEl.classList.add('hidden');
                        confirmSkillButtonEl.classList.remove('hidden');
                        confirmSkillButtonEl.disabled = false;
                        useLuckButtonEl.classList.remove('hidden');
                        useLuckButtonEl.disabled = player.luckPoints <= 0;
                    });
                },
                useLuck: function() { 
                     if (!gameActive || currentPlayer !== player || player.luckPoints <= 0 || diceRollInterval) return;

                    player.luckPoints--;
                    this.logMessage(`${player.name}はラックポイントを1使用してサイコロを振り直します...`);
                    this.updateCharacterUI(); 
                    diceDisplayEl.textContent = "?";

                    this._animateDiceRoll(false, () => { 
                        currentDiceRoll = Math.floor(Math.random() * 6) + 1;
                        diceDisplayEl.textContent = currentDiceRoll;
                        this.logMessage(`${player.name}の新しい目は「${currentDiceRoll}」だ！`);

                        this.logSkillDetails(player.skills[currentDiceRoll], currentDiceRoll);
                        
                        skillSlots.forEach(slot => slot.classList.remove('highlighted'));
                        if (skillSlots[currentDiceRoll - 1]) {
                            skillSlots[currentDiceRoll - 1].classList.add('highlighted');
                        }
                        
                        confirmSkillButtonEl.disabled = false; 
                        useLuckButtonEl.disabled = player.luckPoints <= 0;
                    });
                },
                confirmSkill: function() { 
                     if (!gameActive || currentPlayer !== player || currentDiceRoll === undefined || diceRollInterval) return;
                    
                    confirmSkillButtonEl.disabled = true;
                    useLuckButtonEl.disabled = true;

                    this.useSkill(player, opponent, currentDiceRoll, true); 
                    currentDiceRoll = undefined; 

                    confirmSkillButtonEl.classList.add('hidden');
                    useLuckButtonEl.classList.add('hidden');
                },
                useSkill: function(attacker, defender, diceResult, isPlayerAction = false) {
                    if (!gameActive) return;
                    const skill = attacker.skills[diceResult];

                    if (skill && typeof skill.effect === 'function') {
                        this.logMessage(`${attacker.name}の技「${skill.name}」(${skill.type})が発動！`);
                        if (attacker === opponent) { 
                             this.logMessage(` > ${skill.description}`);
                        }
                        
                        if (skill.type === "攻撃") playSoundEffect(sounds.skillAttack);
                        else if (skill.type === "回復") playSoundEffect(sounds.skillHeal);

                        const needsInternalRoll = skill.name === "メガトンプレス" || skill.name === "ハイドロポンプ";

                        if (needsInternalRoll) {
                            skill.effect(attacker, defender, this); 
                        } else {
                            skill.effect(attacker, defender, this);
                            this.updateCharacterUI(); 
                            if (this.checkGameOver()) return;
                            
                            if (isPlayerAction && attacker === player && gameActive) {
                                setTimeout(() => this.endTurn(), TURN_TRANSITION_DELAY);
                            } else if (attacker === opponent && gameActive) { 
                                setTimeout(() => this.endTurn(), TURN_TRANSITION_DELAY);
                            }
                        }
                    } else {
                        this.logMessage(`${attacker.name}の${diceResult}の目に対応する技はありません。`);
                         if (isPlayerAction && attacker === player && gameActive) { 
                           setTimeout(() => this.endTurn(), TURN_TRANSITION_DELAY);
                        } else if (attacker === opponent && gameActive) { 
                           setTimeout(() => this.endTurn(), TURN_TRANSITION_DELAY);
                        }
                    }
                },
                dealDamage: function(target, amount, attacker, isRecoil = false) {
                    if (!target || !attacker) return;
                    playSoundEffect(sounds.damage); 
                    let actualDamage = amount;
                    
                    if (attacker.id === 'volfang' && attacker.trait.name === "闘争本能" && attacker.hp <= attacker.maxHp / 2 && !isRecoil) {
                         actualDamage = Math.floor(actualDamage * 1.2); 
                    }

                    if (target.id === 'basaltus' && target.trait.name === "頑強な甲殻" && !isRecoil) {
                        actualDamage = Math.max(1, Math.floor(actualDamage * 0.8)); 
                        this.logMessage(`${target.name}の特性「頑強な甲殻」でダメージが軽減された！`);
                    }
                    
                    const attackBuff = attacker.statusConditions.find(s => s.stat === 'attack' && s.type === 'buff');
                    if (attackBuff && !isRecoil) actualDamage = Math.floor(actualDamage * attackBuff.value);
                    
                    const defenseBuff = target.statusConditions.find(s => s.stat === 'defense' && s.type === 'buff');
                    if (defenseBuff && !isRecoil) {
                        actualDamage = Math.floor(actualDamage * defenseBuff.value); 
                    }
                    
                    const attackDebuff = attacker.statusConditions.find(s => s.stat === 'attack' && s.type === 'debuff');
                    if (attackDebuff && !isRecoil) actualDamage = Math.floor(actualDamage * attackDebuff.value); 

                    actualDamage = Math.max(0, Math.round(actualDamage)); 

                    target.hp = Math.max(0, target.hp - actualDamage);
                    if (!isRecoil) {
                        this.logMessage(`${target.name}は ${actualDamage} のダメージを受けた！`);
                    } else {
                         this.logMessage(`${attacker.name}は反動で ${actualDamage} のダメージを受けた！`);
                    }
                },
                healDamage: function(target, amount) {
                    if (!target) return;
                    target.hp = Math.min(target.maxHp, target.hp + amount);
                    this.logMessage(`${target.name}のHPが ${amount} 回復した！`);
                },
                addStatus: function(character, status) { 
                    if (!character) return;
                    const existingStatus = character.statusConditions.find(s => s.name === status.name);
                    if (existingStatus) {
                        existingStatus.turns = Math.max(existingStatus.turns, status.turns);
                    } else {
                        character.statusConditions.push(JSON.parse(JSON.stringify(status))); 
                    }
                },
                applyEndOfTurnEffects: function(character) {
                    if (!character || !character.statusConditions) return true; 
                    const effectsToApply = [...character.statusConditions]; 
                    
                    effectsToApply.forEach(status => {
                        if (!status) return; 
                        if (status.type === 'dot' && typeof status.damage === 'number') {
                            this.dealDamage(character, status.damage, character, true); 
                        }
                        if (status.type === 'hot' && typeof status.heal === 'number') {
                            this.healDamage(character, status.heal);
                        }
                        status.turns--;
                    });
                    character.statusConditions = character.statusConditions.filter(s => s && s.turns > 0);
                    return true; 
                },
                checkGameOver: function() {
                     if (!player || !opponent) return false;
                    if (player.hp <= 0) {
                        this.endGame(`${opponent.name}の勝利！`);
                        return true;
                    }
                    if (opponent.hp <= 0) {
                        this.endGame(`${player.name}の勝利！`);
                        return true;
                    }
                    return false;
                },
                endGame: function(message) {
                    gameActive = false;
                    stopBGM();
                    if (player && message.includes(player.name)) { 
                        playSoundEffect(sounds.win);
                    } else { 
                        playSoundEffect(sounds.lose);
                    }

                    if (diceRollInterval) { 
                        clearInterval(diceRollInterval);
                        diceRollInterval = null;
                        diceDisplayEl.classList.remove('rolling');
                    }
                    this.logMessage(message);
                    this.logMessage("ゲーム終了。");
                    gameOverMessageEl.textContent = message;
                    gameOverModalEl.style.display = 'flex';
                    rollDiceButtonEl.disabled = true;
                    useLuckButtonEl.disabled = true;
                    confirmSkillButtonEl.disabled = true;
                },
                startTurn: function() {
                    if (!gameActive) return;
                    turnCount++;
                    currentDiceRoll = undefined; 
                    this.logMessage(`--- ターン ${turnCount} (${currentPlayer.name}) ---`);

                    if (currentPlayer.trait && currentPlayer.trait.apply) {
                        currentPlayer.trait.apply(currentPlayer, (currentPlayer === player ? opponent : player), this);
                    }
                    this.updateCharacterUI(); 

                    const canAct = this.applyPreTurnStatusEffects(currentPlayer);
                     this.updateCharacterUI(); 

                    if (!canAct) { 
                        setTimeout(() => this.endTurn(), TURN_TRANSITION_DELAY);
                        return;
                    }
                     if (!gameActive) return; 

                    if (currentPlayer === player && turnCount > 0 && turnCount % 3 === 0) {
                        if (player.luckPoints < 3) {
                            player.luckPoints++;
                            this.logMessage(`${player.name}はラックポイントを1獲得した！ (現在: ${player.luckPoints})`);
                            this.updateCharacterUI(); 
                        }
                    }

                    diceDisplayEl.textContent = '?';
                    skillSlots.forEach(slot => slot.classList.remove('highlighted'));

                    if (currentPlayer === player) {
                        rollDiceButtonEl.classList.remove('hidden');
                        rollDiceButtonEl.disabled = false;
                        confirmSkillButtonEl.classList.add('hidden');
                        confirmSkillButtonEl.disabled = true;
                        useLuckButtonEl.classList.add('hidden');
                        useLuckButtonEl.disabled = true; 
                    } else { 
                        rollDiceButtonEl.classList.add('hidden');
                        rollDiceButtonEl.disabled = true;
                        confirmSkillButtonEl.classList.add('hidden');
                        confirmSkillButtonEl.disabled = true;
                        useLuckButtonEl.classList.add('hidden');
                        useLuckButtonEl.disabled = true;
                        setTimeout(() => this.cpuTurn(), TURN_TRANSITION_DELAY / 2); 
                    }
                },
                applyPreTurnStatusEffects: function(character) {
                    if (!character || !character.statusConditions) return true;
                    let canAct = true;
                    const actionStoppingStatus = character.statusConditions.find(
                        status => status.name === '麻痺' || status.name === '怯み' || status.name === '行動不能'
                    );

                    if (actionStoppingStatus && actionStoppingStatus.turns > 0) {
                        this.logMessage(`${character.name}は${actionStoppingStatus.name}のため、このターンは行動できない！`);
                        canAct = false;
                    }
                    
                    const confusionStatus = character.statusConditions.find(status => status.name === '混乱');
                    if (canAct && confusionStatus && confusionStatus.turns > 0 && Math.random() < 0.5) { 
                        this.logMessage(`${character.name}は混乱して自分を攻撃してしまった！`);
                        this.dealDamage(character, 20, character, true); 
                        canAct = false; 
                        if (this.checkGameOver()) return false; 
                    }
                    return canAct;
                },
                endTurn: function() {
                    if (!gameActive) return;
                    if (currentPlayer === player) {
                        rollDiceButtonEl.classList.add('hidden');
                        rollDiceButtonEl.disabled = true;
                        confirmSkillButtonEl.classList.add('hidden');
                        confirmSkillButtonEl.disabled = true;
                        useLuckButtonEl.classList.add('hidden');
                        useLuckButtonEl.disabled = true;
                    }

                    this.logMessage(`${currentPlayer.name}のターン終了処理中...`);
                    this.applyEndOfTurnEffects(currentPlayer); 
                    this.updateCharacterUI(); 

                    if (this.checkGameOver()) return;
                    
                    setTimeout(() => {
                        currentPlayer = (currentPlayer === player) ? opponent : player;
                        this.startTurn();
                    }, TURN_TRANSITION_DELAY);
                },
                cpuTurn: function() {
                    if (!gameActive || !opponent || !player || diceRollInterval) return; 
                    
                    this.logMessage(`${opponent.name}がサイコロを振ります...`);
                    diceDisplayEl.textContent = "?";

                    this._animateDiceRoll(true, () => { 
                        let cpuDiceResult = Math.floor(Math.random() * 6) + 1;
                        diceDisplayEl.textContent = cpuDiceResult;
                        this.logMessage(`${opponent.name}はサイコロを振って「${cpuDiceResult}」が出た！`);
                        
                        this.logSkillDetails(opponent.skills[cpuDiceResult], cpuDiceResult);

                        const skillToUse = opponent.skills[cpuDiceResult];
                        let shouldUseLuck = false;
                        if (skillToUse) {
                            if (skillToUse.name === "たいあたり" && opponent.luckPoints > 0 && Math.random() < 0.5) {
                                shouldUseLuck = true;
                            }
                            if (cpuDiceResult <= 2 && opponent.luckPoints > 0 && Math.random() < 0.3) { 
                                 shouldUseLuck = true;
                            }
                        }

                        setTimeout(() => {
                            if (shouldUseLuck) {
                                opponent.luckPoints--;
                                this.logMessage(`${opponent.name}はラックポイントを1使用してサイコロを振り直します...`);
                                diceDisplayEl.textContent = "?"; 
                                this._animateDiceRoll(true, () => { 
                                    cpuDiceResult = Math.floor(Math.random() * 6) + 1;
                                    diceDisplayEl.textContent = cpuDiceResult;
                                    this.logMessage(`${opponent.name}の新しい目は「${cpuDiceResult}」だ！`);
                                    this.logSkillDetails(opponent.skills[cpuDiceResult], cpuDiceResult);
                                    this.useSkill(opponent, player, cpuDiceResult);
                                }, 800); 
                            } else {
                                this.useSkill(opponent, player, cpuDiceResult);
                            }
                        }, 1000); 

                    }, 1200); 
                },
                initializeGame: function(playerCharId, opponentCharId) {
                    player = cloneCharacter(playerCharId);
                    opponent = cloneCharacter(opponentCharId);

                    if (!player || !opponent) {
                        this.logMessage("エラー: キャラクターの読み込みに失敗しました。");
                        characterSelectionModalEl.style.display = 'flex';
                        return;
                    }
                    
                    turnCount = 0;
                    gameActive = true;
                    currentDiceRoll = undefined;

                    stopBGM(); 
                    playBGM(sounds.battleBGM, true); 

                    messageLogAreaEl.innerHTML = ''; 
                    this.logMessage("ゲーム開始！");
                    this.logMessage(`プレイヤー: ${player.name} vs CPU: ${opponent.name}`);
                    
                    const playerSpeedRoll = player.speed + Math.random() * 20; 
                    const opponentSpeedRoll = opponent.speed + Math.random() * 20;

                    if (playerSpeedRoll >= opponentSpeedRoll) {
                        currentPlayer = player;
                        this.logMessage(`${player.name}の先行！`);
                        this.updateCharacterUI(); 
                        characterSelectionModalEl.style.display = 'none';
                        gameOverModalEl.style.display = 'none';
                        rollDiceButtonEl.classList.remove('hidden');
                        rollDiceButtonEl.disabled = true; 
                        confirmSkillButtonEl.classList.add('hidden');
                        confirmSkillButtonEl.disabled = true;
                        useLuckButtonEl.classList.add('hidden');
                        useLuckButtonEl.disabled = true;
                        this.startTurn(); 
                    } else {
                        currentPlayer = opponent;
                        this.logMessage(`${opponent.name}の先行！`);
                        this.updateCharacterUI(); 
                        characterSelectionModalEl.style.display = 'none';
                        gameOverModalEl.style.display = 'none';
                        rollDiceButtonEl.classList.add('hidden'); 
                        rollDiceButtonEl.disabled = true;
                        confirmSkillButtonEl.classList.add('hidden');
                        confirmSkillButtonEl.disabled = true;
                        useLuckButtonEl.classList.add('hidden');
                        useLuckButtonEl.disabled = true;
                        setTimeout(() => this.startTurn(), TURN_TRANSITION_DELAY); 
                    }
                },

                setupCharacterSelection: function() {
                    stopBGM(); 
                    playBGM(sounds.titleBGM, true); 

                    characterChoicesEl.innerHTML = ''; 
                    Object.values(characters).forEach(char => {
                        const card = document.createElement('div');
                        card.className = 'character-card';
                        card.onclick = () => {
                            if (!audioContextAllowed && currentBGM && currentBGM.paused) {
                                resumeAudioContext();
                            }
                            const availableOpponents = Object.keys(characters).filter(id => id !== char.id);
                            const randomOpponentId = availableOpponents[Math.floor(Math.random() * availableOpponents.length)];
                            this.initializeGame(char.id, randomOpponentId);
                        };

                        let skillsHtml = '<ul>';
                        char.skills.forEach((skill, index) => {
                            if (skill) { 
                                let skillDetail = `${index}: ${skill.name}`;
                                if (skill.power) skillDetail += ` (威力:${skill.power})`;
                                else if (skill.heal) skillDetail += ` (回復:${skill.heal})`;
                                skillsHtml += `<li>${skillDetail}</li>`;
                            }
                        });
                        skillsHtml += '</ul>';

                        card.innerHTML = `
                            <img src="${char.imageFile}" alt="${char.name}画像" class="card-char-image" onerror="this.onerror=null; this.src='https://placehold.co/300x225/333333/FFFFFF?text=${encodeURIComponent(char.name)}';">
                            <h3 class="card-char-name">${char.name}</h3>
                            <div class="card-stats">
                                <p>HP: ${char.hp} / ${char.maxHp}</p>
                                <p>速さ: ${char.speed}</p>
                            </div>
                            <div class="card-trait">
                                <p class="card-section-title">特性</p>
                                <p><span class="trait-name">${char.trait.name}:</span> ${char.trait.description}</p>
                            </div>
                            <div class="card-skills">
                                <p class="card-section-title">技リスト</p>
                                ${skillsHtml}
                            </div>
                        `;
                        characterChoicesEl.appendChild(card);
                    });
                    characterSelectionModalEl.style.display = 'flex';
                }
            };

            // --- Event Listeners ---
            rollDiceButtonEl.addEventListener('click', () => game.rollDice()); 
            useLuckButtonEl.addEventListener('click', () => game.useLuck()); 
            confirmSkillButtonEl.addEventListener('click', () => game.confirmSkill()); 
            playAgainButtonEl.addEventListener('click', () => {
                game.setupCharacterSelection();
            });
            
            function initialUserInteractionListener() {
                resumeAudioContext();
                document.body.removeEventListener('click', initialUserInteractionListener);
                document.body.removeEventListener('touchstart', initialUserInteractionListener);
            }
            document.body.addEventListener('click', initialUserInteractionListener, { once: true });
            document.body.addEventListener('touchstart', initialUserInteractionListener, { once: true });


            // --- Initialize ---
            game.setupCharacterSelection();
            const bodyStyle = getComputedStyle(document.body);
            if (!bodyStyle.backgroundImage || bodyStyle.backgroundImage === "none") {
                 console.warn("背景画像 'images/闘技場.png' の読み込みに失敗したか、指定されていません。");
                 document.body.style.backgroundColor = "#2c3e50"; // Fallback background
            }

        })();
    </script>
</body>
</html>
